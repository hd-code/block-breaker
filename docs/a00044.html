<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>YoshiX Shader Function: gfx Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">YoshiX Shader Function
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">gfx Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Encapsulates all types and methods of the YoshiX frame work.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00001.html">IApplication</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines an application which can be run by the render pipeline.  <a href="a00001.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html">SDepthTest</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulates the enumeration of depth test policies.  <a href="a00002.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a2594f4af34f62830d406887995a864be"><td class="memItemLeft" align="right" valign="top">typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#a2594f4af34f62830d406887995a864be">BHandle</a></td></tr>
<tr class="memdesc:a2594f4af34f62830d406887995a864be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle to an internal resource of the YoshiX frame work.  <a href="#a2594f4af34f62830d406887995a864be">More...</a><br/></td></tr>
<tr class="separator:a2594f4af34f62830d406887995a864be"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2154b88e3aa131b27d95017434e6ee30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#a2154b88e3aa131b27d95017434e6ee30">CreateColorTarget</a> (<a class="el" href="a00044.html#a2594f4af34f62830d406887995a864be">BHandle</a> *_ppTexture)</td></tr>
<tr class="memdesc:a2154b88e3aa131b27d95017434e6ee30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new color render target.  <a href="#a2154b88e3aa131b27d95017434e6ee30">More...</a><br/></td></tr>
<tr class="separator:a2154b88e3aa131b27d95017434e6ee30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40e4d727dd9f8f5627b2147fb187e716"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#a40e4d727dd9f8f5627b2147fb187e716">CreateConstantBuffer</a> (int _NumberOfBytes, <a class="el" href="a00044.html#a2594f4af34f62830d406887995a864be">BHandle</a> *_ppConstantBuffer)</td></tr>
<tr class="memdesc:a40e4d727dd9f8f5627b2147fb187e716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new constant buffer.  <a href="#a40e4d727dd9f8f5627b2147fb187e716">More...</a><br/></td></tr>
<tr class="separator:a40e4d727dd9f8f5627b2147fb187e716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6ed74de87429cb07cf8fb3840a2803d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#ad6ed74de87429cb07cf8fb3840a2803d">CreateDepthTarget</a> (<a class="el" href="a00044.html#a2594f4af34f62830d406887995a864be">BHandle</a> *_ppTexture)</td></tr>
<tr class="memdesc:ad6ed74de87429cb07cf8fb3840a2803d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new depth render target.  <a href="#ad6ed74de87429cb07cf8fb3840a2803d">More...</a><br/></td></tr>
<tr class="separator:ad6ed74de87429cb07cf8fb3840a2803d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a414db99422f8c59c7bf59104e260bb5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#a414db99422f8c59c7bf59104e260bb5b">CreateMaterial</a> (const SMaterialInfo &amp;_rMaterialInfo, <a class="el" href="a00044.html#a2594f4af34f62830d406887995a864be">BHandle</a> *_ppMaterial)</td></tr>
<tr class="memdesc:a414db99422f8c59c7bf59104e260bb5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a material.  <a href="#a414db99422f8c59c7bf59104e260bb5b">More...</a><br/></td></tr>
<tr class="separator:a414db99422f8c59c7bf59104e260bb5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab769ea5d4030f74ea6db67f29202a33b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#ab769ea5d4030f74ea6db67f29202a33b">CreateMesh</a> (const SMeshInfo &amp;_rMeshInfo, <a class="el" href="a00044.html#a2594f4af34f62830d406887995a864be">BHandle</a> *_ppMesh)</td></tr>
<tr class="memdesc:ab769ea5d4030f74ea6db67f29202a33b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new mesh.  <a href="#ab769ea5d4030f74ea6db67f29202a33b">More...</a><br/></td></tr>
<tr class="separator:ab769ea5d4030f74ea6db67f29202a33b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e949b9d7b64f908dbe7642a35ced6c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#a4e949b9d7b64f908dbe7642a35ced6c1">CreatePixelShader</a> (const char *_pPath, const char *_pShaderName, <a class="el" href="a00044.html#a2594f4af34f62830d406887995a864be">BHandle</a> *_ppShader)</td></tr>
<tr class="memdesc:a4e949b9d7b64f908dbe7642a35ced6c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compiles and creates a pixel shader.  <a href="#a4e949b9d7b64f908dbe7642a35ced6c1">More...</a><br/></td></tr>
<tr class="separator:a4e949b9d7b64f908dbe7642a35ced6c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a831ad24692845847b33c3e5345f36654"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#a831ad24692845847b33c3e5345f36654">CreateTexture</a> (const char *_pPath, <a class="el" href="a00044.html#a2594f4af34f62830d406887995a864be">BHandle</a> *_ppTexture)</td></tr>
<tr class="memdesc:a831ad24692845847b33c3e5345f36654"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new texture.  <a href="#a831ad24692845847b33c3e5345f36654">More...</a><br/></td></tr>
<tr class="separator:a831ad24692845847b33c3e5345f36654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb193095d1e10af99955603a31e35ed1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#adb193095d1e10af99955603a31e35ed1">CreateVertexShader</a> (const char *_pPath, const char *_pShaderName, <a class="el" href="a00044.html#a2594f4af34f62830d406887995a864be">BHandle</a> *_ppShader)</td></tr>
<tr class="memdesc:adb193095d1e10af99955603a31e35ed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compiles and creates a vertex shader.  <a href="#adb193095d1e10af99955603a31e35ed1">More...</a><br/></td></tr>
<tr class="separator:adb193095d1e10af99955603a31e35ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add0cfb7c2c91924c2c1e826a741063e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#add0cfb7c2c91924c2c1e826a741063e5">DrawMesh</a> (<a class="el" href="a00044.html#a2594f4af34f62830d406887995a864be">BHandle</a> _pMesh)</td></tr>
<tr class="memdesc:add0cfb7c2c91924c2c1e826a741063e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visualizes a mesh.  <a href="#add0cfb7c2c91924c2c1e826a741063e5">More...</a><br/></td></tr>
<tr class="separator:add0cfb7c2c91924c2c1e826a741063e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b6f8f713c5b0dbcfa1aa088e9a3d707"><td class="memItemLeft" align="right" valign="top">float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#a7b6f8f713c5b0dbcfa1aa088e9a3d707">GetCrossProduct</a> (const float *_pVector1, const float *_pVector2, float *_pResultVector)</td></tr>
<tr class="memdesc:a7b6f8f713c5b0dbcfa1aa088e9a3d707"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the cross product between two 3D vectors.  <a href="#a7b6f8f713c5b0dbcfa1aa088e9a3d707">More...</a><br/></td></tr>
<tr class="separator:a7b6f8f713c5b0dbcfa1aa088e9a3d707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a802008b02b1afcdbb9b8a3d0c9f1e3b7"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#a802008b02b1afcdbb9b8a3d0c9f1e3b7">GetDotProduct2D</a> (const float *_pVector1, const float *_pVector2)</td></tr>
<tr class="memdesc:a802008b02b1afcdbb9b8a3d0c9f1e3b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product between two 2D vectors.  <a href="#a802008b02b1afcdbb9b8a3d0c9f1e3b7">More...</a><br/></td></tr>
<tr class="separator:a802008b02b1afcdbb9b8a3d0c9f1e3b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeff22e2da4db1cc3fe6d512be9251bfc"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#aeff22e2da4db1cc3fe6d512be9251bfc">GetDotProduct3D</a> (const float *_pVector1, const float *_pVector2)</td></tr>
<tr class="memdesc:aeff22e2da4db1cc3fe6d512be9251bfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product between two 3D vectors.  <a href="#aeff22e2da4db1cc3fe6d512be9251bfc">More...</a><br/></td></tr>
<tr class="separator:aeff22e2da4db1cc3fe6d512be9251bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64f6a8f964674a2ecd70db184ca27a74"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#a64f6a8f964674a2ecd70db184ca27a74">GetDotProduct4D</a> (const float *_pVector1, const float *_pVector2)</td></tr>
<tr class="memdesc:a64f6a8f964674a2ecd70db184ca27a74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product between two 4D vectors.  <a href="#a64f6a8f964674a2ecd70db184ca27a74">More...</a><br/></td></tr>
<tr class="separator:a64f6a8f964674a2ecd70db184ca27a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a659b75013aff150b3c8ec89ef71054b3"><td class="memItemLeft" align="right" valign="top">float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#a659b75013aff150b3c8ec89ef71054b3">GetNormalizedVector</a> (const float *_pVector, float *_pResultVector)</td></tr>
<tr class="memdesc:a659b75013aff150b3c8ec89ef71054b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes the a 3D vector to the length 1.  <a href="#a659b75013aff150b3c8ec89ef71054b3">More...</a><br/></td></tr>
<tr class="separator:a659b75013aff150b3c8ec89ef71054b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c8adde793a7665f30d8b9929fba0da8"><td class="memItemLeft" align="right" valign="top">float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#a7c8adde793a7665f30d8b9929fba0da8">GetProjectionMatrix</a> (float _FieldOfViewY, float _AspectRatio, float _Near, float _Far, float *_pResultMatrix)</td></tr>
<tr class="memdesc:a7c8adde793a7665f30d8b9929fba0da8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a 4x4 matrix which defines the clip space transformation.  <a href="#a7c8adde793a7665f30d8b9929fba0da8">More...</a><br/></td></tr>
<tr class="separator:a7c8adde793a7665f30d8b9929fba0da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a722fce1d717d7ac6a267497d2e953f31"><td class="memItemLeft" align="right" valign="top">float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#a722fce1d717d7ac6a267497d2e953f31">GetRotationXMatrix</a> (float _Degrees, float *_pResultMatrix)</td></tr>
<tr class="memdesc:a722fce1d717d7ac6a267497d2e953f31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 4x4 rotation matrix around the x-axis.  <a href="#a722fce1d717d7ac6a267497d2e953f31">More...</a><br/></td></tr>
<tr class="separator:a722fce1d717d7ac6a267497d2e953f31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18874b5ad14fca0eb337801f59282317"><td class="memItemLeft" align="right" valign="top">float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#a18874b5ad14fca0eb337801f59282317">GetRotationYMatrix</a> (float _Degrees, float *_pResultMatrix)</td></tr>
<tr class="memdesc:a18874b5ad14fca0eb337801f59282317"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 4x4 rotation matrix around the y-axis.  <a href="#a18874b5ad14fca0eb337801f59282317">More...</a><br/></td></tr>
<tr class="separator:a18874b5ad14fca0eb337801f59282317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177cad1cdbdcc5b63399d4e315d85c18"><td class="memItemLeft" align="right" valign="top">float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#a177cad1cdbdcc5b63399d4e315d85c18">GetRotationZMatrix</a> (float _Degrees, float *_pResultMatrix)</td></tr>
<tr class="memdesc:a177cad1cdbdcc5b63399d4e315d85c18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 4x4 rotation matrix around the z-axis.  <a href="#a177cad1cdbdcc5b63399d4e315d85c18">More...</a><br/></td></tr>
<tr class="separator:a177cad1cdbdcc5b63399d4e315d85c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef7f2087e613503db578fe1c6892132"><td class="memItemLeft" align="right" valign="top">float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#a5ef7f2087e613503db578fe1c6892132">GetScaleMatrix</a> (float _Scalar, float *_pResultMatrix)</td></tr>
<tr class="memdesc:a5ef7f2087e613503db578fe1c6892132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 4x4 uniform scaling matrix.  <a href="#a5ef7f2087e613503db578fe1c6892132">More...</a><br/></td></tr>
<tr class="separator:a5ef7f2087e613503db578fe1c6892132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f70f364a688198840ad9b4e299c02b"><td class="memItemLeft" align="right" valign="top">float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#ad1f70f364a688198840ad9b4e299c02b">GetScaleMatrix</a> (float _ScalarX, float _ScalarY, float _ScalarZ, float *_pResultMatrix)</td></tr>
<tr class="memdesc:ad1f70f364a688198840ad9b4e299c02b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 4x4 scaling matrix.  <a href="#ad1f70f364a688198840ad9b4e299c02b">More...</a><br/></td></tr>
<tr class="separator:ad1f70f364a688198840ad9b4e299c02b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bc546907545a0864a68f18c8f946035"><td class="memItemLeft" align="right" valign="top">float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#a1bc546907545a0864a68f18c8f946035">GetScreenMatrix</a> (float *_pResultMatrix)</td></tr>
<tr class="memdesc:a1bc546907545a0864a68f18c8f946035"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a 4x4 view projection matrix for post effects.  <a href="#a1bc546907545a0864a68f18c8f946035">More...</a><br/></td></tr>
<tr class="separator:a1bc546907545a0864a68f18c8f946035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ec8084e3d9029a47e845cac15d3f58"><td class="memItemLeft" align="right" valign="top">float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#a57ec8084e3d9029a47e845cac15d3f58">GetTranslationMatrix</a> (float _X, float _Y, float _Z, float *_pResultMatrix)</td></tr>
<tr class="memdesc:a57ec8084e3d9029a47e845cac15d3f58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 4x4 identity matrix.  <a href="#a57ec8084e3d9029a47e845cac15d3f58">More...</a><br/></td></tr>
<tr class="separator:a57ec8084e3d9029a47e845cac15d3f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82bff593a031d915a46fc1cde9850845"><td class="memItemLeft" align="right" valign="top">float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#a82bff593a031d915a46fc1cde9850845">GetViewMatrix</a> (float *_pEye, float *_pAt, float *_pUp, float *_pResultMatrix)</td></tr>
<tr class="memdesc:a82bff593a031d915a46fc1cde9850845"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a 4x4 matrix to transform the world into view space.  <a href="#a82bff593a031d915a46fc1cde9850845">More...</a><br/></td></tr>
<tr class="separator:a82bff593a031d915a46fc1cde9850845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbd9fd02aa3569485d1bd1fecf83e942"><td class="memItemLeft" align="right" valign="top">float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#acbd9fd02aa3569485d1bd1fecf83e942">MulMatrix</a> (const float *_pLeftMatrix, const float *_pRightMatrix, float *_pResultMatrix)</td></tr>
<tr class="memdesc:acbd9fd02aa3569485d1bd1fecf83e942"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies two 4x4 matrices.  <a href="#acbd9fd02aa3569485d1bd1fecf83e942">More...</a><br/></td></tr>
<tr class="separator:acbd9fd02aa3569485d1bd1fecf83e942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85888529ad66200d6547ae34fe6ec739"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#a85888529ad66200d6547ae34fe6ec739">ReleaseConstantBuffer</a> (<a class="el" href="a00044.html#a2594f4af34f62830d406887995a864be">BHandle</a> _pConstantBuffer)</td></tr>
<tr class="memdesc:a85888529ad66200d6547ae34fe6ec739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases a constant buffer.  <a href="#a85888529ad66200d6547ae34fe6ec739">More...</a><br/></td></tr>
<tr class="separator:a85888529ad66200d6547ae34fe6ec739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeddab08b55ccd8a16efe82ab53e377e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#aeddab08b55ccd8a16efe82ab53e377e5">ReleaseMaterial</a> (<a class="el" href="a00044.html#a2594f4af34f62830d406887995a864be">BHandle</a> _pMaterial)</td></tr>
<tr class="memdesc:aeddab08b55ccd8a16efe82ab53e377e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases a material.  <a href="#aeddab08b55ccd8a16efe82ab53e377e5">More...</a><br/></td></tr>
<tr class="separator:aeddab08b55ccd8a16efe82ab53e377e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae762f5085fa492ae0492dc5c47cae38d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#ae762f5085fa492ae0492dc5c47cae38d">ReleaseMesh</a> (<a class="el" href="a00044.html#a2594f4af34f62830d406887995a864be">BHandle</a> _pMesh)</td></tr>
<tr class="memdesc:ae762f5085fa492ae0492dc5c47cae38d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the resources of a mesh.  <a href="#ae762f5085fa492ae0492dc5c47cae38d">More...</a><br/></td></tr>
<tr class="separator:ae762f5085fa492ae0492dc5c47cae38d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c27f43ce73dff5bd60a3608df827ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#a78c27f43ce73dff5bd60a3608df827ec">ReleasePixelShader</a> (<a class="el" href="a00044.html#a2594f4af34f62830d406887995a864be">BHandle</a> _pShader)</td></tr>
<tr class="memdesc:a78c27f43ce73dff5bd60a3608df827ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases a pixel shader.  <a href="#a78c27f43ce73dff5bd60a3608df827ec">More...</a><br/></td></tr>
<tr class="separator:a78c27f43ce73dff5bd60a3608df827ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a949f8894f31d7a6b933a3d4ae2442517"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#a949f8894f31d7a6b933a3d4ae2442517">ReleaseTexture</a> (<a class="el" href="a00044.html#a2594f4af34f62830d406887995a864be">BHandle</a> _pTexture)</td></tr>
<tr class="memdesc:a949f8894f31d7a6b933a3d4ae2442517"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the resources of a texture.  <a href="#a949f8894f31d7a6b933a3d4ae2442517">More...</a><br/></td></tr>
<tr class="separator:a949f8894f31d7a6b933a3d4ae2442517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c4e5a2c5ab4b888ae3b0c52d104bc9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#a6c4e5a2c5ab4b888ae3b0c52d104bc9a">ReleaseVertexShader</a> (<a class="el" href="a00044.html#a2594f4af34f62830d406887995a864be">BHandle</a> _pShader)</td></tr>
<tr class="memdesc:a6c4e5a2c5ab4b888ae3b0c52d104bc9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases a vertex shader.  <a href="#a6c4e5a2c5ab4b888ae3b0c52d104bc9a">More...</a><br/></td></tr>
<tr class="separator:a6c4e5a2c5ab4b888ae3b0c52d104bc9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3439794d716c31e4a42b523825b24b44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#a3439794d716c31e4a42b523825b24b44">RunApplication</a> (int _Width, int _Height, const char *_pTitle, <a class="el" href="a00001.html">IApplication</a> *_pApplication)</td></tr>
<tr class="memdesc:a3439794d716c31e4a42b523825b24b44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs a YoshiX application.  <a href="#a3439794d716c31e4a42b523825b24b44">More...</a><br/></td></tr>
<tr class="separator:a3439794d716c31e4a42b523825b24b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb8029d85c8f246685de35497120b32b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#aeb8029d85c8f246685de35497120b32b">SetAlphaBlending</a> (bool _Flag)</td></tr>
<tr class="memdesc:aeb8029d85c8f246685de35497120b32b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activates or deactivates the alpha blending mode.  <a href="#aeb8029d85c8f246685de35497120b32b">More...</a><br/></td></tr>
<tr class="separator:aeb8029d85c8f246685de35497120b32b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fa166e38ebc294b733cd4948c558299"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#a4fa166e38ebc294b733cd4948c558299">SetClearColor</a> (const float *_pColor)</td></tr>
<tr class="memdesc:a4fa166e38ebc294b733cd4948c558299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the background color of the window.  <a href="#a4fa166e38ebc294b733cd4948c558299">More...</a><br/></td></tr>
<tr class="separator:a4fa166e38ebc294b733cd4948c558299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad6870d4cf62fde0d7ae3ac2fa7d86bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#aad6870d4cf62fde0d7ae3ac2fa7d86bc">SetDepthTest</a> (<a class="el" href="a00002.html#a2a77bf3decc8b6a97e25d240ac4c6a5a">SDepthTest::ETest</a> _Test)</td></tr>
<tr class="memdesc:aad6870d4cf62fde0d7ae3ac2fa7d86bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the depth test type.  <a href="#aad6870d4cf62fde0d7ae3ac2fa7d86bc">More...</a><br/></td></tr>
<tr class="separator:aad6870d4cf62fde0d7ae3ac2fa7d86bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7db3624563f003481a8fd75b5bd8679"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#ad7db3624563f003481a8fd75b5bd8679">SetWireFrame</a> (bool _Flag)</td></tr>
<tr class="memdesc:ad7db3624563f003481a8fd75b5bd8679"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activates or deactivates the wire frame mode.  <a href="#ad7db3624563f003481a8fd75b5bd8679">More...</a><br/></td></tr>
<tr class="separator:ad7db3624563f003481a8fd75b5bd8679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5503e7a976d680eb47728da573361920"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#a5503e7a976d680eb47728da573361920">StopApplication</a> ()</td></tr>
<tr class="memdesc:a5503e7a976d680eb47728da573361920"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops the current application.  <a href="#a5503e7a976d680eb47728da573361920">More...</a><br/></td></tr>
<tr class="separator:a5503e7a976d680eb47728da573361920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa53c0b264e53a7101a0e268736e391a9"><td class="memItemLeft" align="right" valign="top">float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#aa53c0b264e53a7101a0e268736e391a9">TransformVector</a> (const float *_pVector, const float *_pMatrix, float *_pResultVector)</td></tr>
<tr class="memdesc:aa53c0b264e53a7101a0e268736e391a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a 3D vector by a 4x4 matrix.  <a href="#aa53c0b264e53a7101a0e268736e391a9">More...</a><br/></td></tr>
<tr class="separator:aa53c0b264e53a7101a0e268736e391a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52050e7be3868189d6a0153730a429c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#a52050e7be3868189d6a0153730a429c8">UploadConstantBuffer</a> (void *_pData, <a class="el" href="a00044.html#a2594f4af34f62830d406887995a864be">BHandle</a> _pConstantBuffer)</td></tr>
<tr class="memdesc:a52050e7be3868189d6a0153730a429c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uploads a byte block into the constant buffer on the GPU.  <a href="#a52050e7be3868189d6a0153730a429c8">More...</a><br/></td></tr>
<tr class="separator:a52050e7be3868189d6a0153730a429c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Encapsulates all types and methods of the YoshiX frame work. </p>
<p>Encapsulates all types and methods of the YoshiX frame work.</p>
<dl class="section warning"><dt>Warning</dt><dd>Do not declare using statements in a header file. </dd></dl>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a2594f4af34f62830d406887995a864be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00044.html#a2594f4af34f62830d406887995a864be">gfx::BHandle</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handle to an internal resource of the YoshiX frame work. </p>
<p>Handle to an internal resource of the YoshiX frame work. The idea of a handle is similar to a ticket: When passing the handle to YoshiX then it grants access to the functionality of the resource addressed by the handle.</p>
<dl class="section warning"><dt>Warning</dt><dd>Do not forget to release created resources again. </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a2154b88e3aa131b27d95017434e6ee30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gfx::CreateColorTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00044.html#a2594f4af34f62830d406887995a864be">BHandle</a> *&#160;</td>
          <td class="paramname"><em>_ppTexture</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new color render target. </p>
<p>A color render target is a color buffer, in which a scene can be rendered. This is similar to the standard frame buffer with the exception that the result is not visible on the screen. Instead the color render target can be set as a shader resource, i.e. as a texture which is sampled by a shader program. The created color render target is represented by a handle which is returned in the last argument. The render target has the same width and height as the window. After the render target has been activated via the gfx::SetRenderTargets method all <a class="el" href="a00044.html#add0cfb7c2c91924c2c1e826a741063e5" title="Visualizes a mesh. ">gfx::DrawMesh</a> calls will render into this render target. You can use the handle to add the render target as a texture to a material. Note that while using such a material in a <a class="el" href="a00044.html#add0cfb7c2c91924c2c1e826a741063e5" title="Visualizes a mesh. ">gfx::DrawMesh</a> call the color render target must not be active. In other words: It is not possible to use a texture as a color render target and as a shader input at the same time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_ppTexture</td><td>A pointer to a render target handle which is filled by the method with a valid texture handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00044.html#ad6ed74de87429cb07cf8fb3840a2803d" title="Creates a new depth render target. ">gfx::CreateDepthTarget</a> </dd>
<dd>
<a class="el" href="a00044.html#a949f8894f31d7a6b933a3d4ae2442517" title="Frees the resources of a texture. ">gfx::ReleaseTexture</a> </dd>
<dd>
gfx::SetRenderTargets </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Not thread-safe. </dd></dl>

</div>
</div>
<a class="anchor" id="a40e4d727dd9f8f5627b2147fb187e716"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gfx::CreateConstantBuffer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_NumberOfBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00044.html#a2594f4af34f62830d406887995a864be">BHandle</a> *&#160;</td>
          <td class="paramname"><em>_ppConstantBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new constant buffer. </p>
<p>Creates a new constant buffer. A constant buffer is a group of variables, which are uploaded from the CPU to the GPU. The variables are read by the shader programs, but cannot be changed. That is the reason why they are called constants. The maximum size of one constant buffer is 4096 bytes. Theoretically you can create thousands of them. Note that only 16 constant buffers can be activated per shader stage (vertex shader stage and pixel shader stage) at the same time. So creating a lot of constant buffers is a bad idea because managing and switching between all these buffers will kill the performance of the GPU.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_NumberOfBytes</td><td>The number of bytes requested by all the variables in the constant buffer. </td></tr>
    <tr><td class="paramname">_ppConstantBuffer</td><td>A pointer to a constant buffer handle which is filled by the method with a valid constant buffer handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00044.html#a85888529ad66200d6547ae34fe6ec739" title="Releases a constant buffer. ">gfx::ReleaseConstantBuffer</a> </dd>
<dd>
<a class="el" href="a00044.html#a52050e7be3868189d6a0153730a429c8" title="Uploads a byte block into the constant buffer on the GPU. ">gfx::UploadConstantBuffer</a> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Not thread-safe. </dd></dl>

</div>
</div>
<a class="anchor" id="ad6ed74de87429cb07cf8fb3840a2803d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gfx::CreateDepthTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00044.html#a2594f4af34f62830d406887995a864be">BHandle</a> *&#160;</td>
          <td class="paramname"><em>_ppTexture</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new depth render target. </p>
<p>A depth render target is exactly the same as a color render target, but instead of colors depth values are stored. You can activate depth render targets as the current depth buffer via the gfx::SetRenderTargets method. Then all following <a class="el" href="a00044.html#add0cfb7c2c91924c2c1e826a741063e5" title="Visualizes a mesh. ">gfx::DrawMesh</a> calls will render the depth values in this depth render target. You are also allowed to define the depth render target as a normal material texture. In this way it is possible to read the depth values in a pixel shader. As already mentioned in the <a class="el" href="a00044.html#a2154b88e3aa131b27d95017434e6ee30" title="Creates a new color render target. ">gfx::CreateColorTarget</a> method it is not possible to use a texture as a render target and as a shader input at the same time, so before using the material in a <a class="el" href="a00044.html#add0cfb7c2c91924c2c1e826a741063e5" title="Visualizes a mesh. ">gfx::DrawMesh</a> call you have to activate another depth render target.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_ppTexture</td><td>A pointer to a render target handle which is filled by the method with a valid texture handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00044.html#a2154b88e3aa131b27d95017434e6ee30" title="Creates a new color render target. ">gfx::CreateColorTarget</a> </dd>
<dd>
<a class="el" href="a00044.html#a949f8894f31d7a6b933a3d4ae2442517" title="Frees the resources of a texture. ">gfx::ReleaseTexture</a> </dd>
<dd>
gfx::SetRenderTargets </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Not thread-safe. </dd></dl>

</div>
</div>
<a class="anchor" id="a414db99422f8c59c7bf59104e260bb5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gfx::CreateMaterial </td>
          <td>(</td>
          <td class="paramtype">const SMaterialInfo &amp;&#160;</td>
          <td class="paramname"><em>_rMaterialInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00044.html#a2594f4af34f62830d406887995a864be">BHandle</a> *&#160;</td>
          <td class="paramname"><em>_ppMaterial</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a material. </p>
<p>Creates a material which defines the surface of a mesh. A material is a combination of textures, shader constants, a vertex shader, and a pixel shader. Note that the vertex shader is the connection to a mesh, because it processes each vertex of the mesh. For that reason the vertices of the mesh have to provide exactly the data requested by the input arguments of the vertex shader. See the documentation of the gfx::SMaterialInfo struct to get more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_rMaterialInfo</td><td>A descriptor which defines the content of the material. </td></tr>
    <tr><td class="paramname">_ppMaterial</td><td>A pointer to a material handle which is filled by the method with a valid material handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>gfx::SMaterialInfo </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Not thread-safe. </dd></dl>

</div>
</div>
<a class="anchor" id="ab769ea5d4030f74ea6db67f29202a33b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gfx::CreateMesh </td>
          <td>(</td>
          <td class="paramtype">const SMeshInfo &amp;&#160;</td>
          <td class="paramname"><em>_rMeshInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00044.html#a2594f4af34f62830d406887995a864be">BHandle</a> *&#160;</td>
          <td class="paramname"><em>_ppMesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new mesh. </p>
<p>A mesh is a set of triangles. The vertices of the mesh are defined in local space. Each vertex is represented by an array of 3 float values. The topology of the mesh is defined by triangles. Each triangle is represented by three integer indices, where an index corresponds to the position of a vertex in the vertex array. The mesh is represented by a handle which is returned in the last argument.</p>
<p>A mesh can be covered by a surface. The look of the surface is defined by a material. The mesh and the material are defined by the passed mesh info. If the mesh should be lighted, then the mesh info has to contain normals. If the mesh should be textured then the mesh info has to contain texture coordinates and a handle to a texture. Normals, colors, and texture coordinates are defined per vertex their array size has to match the array size of the vertices. Set all elements to null in the mesh info which are not supported.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_rMeshInfo</td><td>The info which defines the elements of the mesh. </td></tr>
    <tr><td class="paramname">_ppMesh</td><td>A pointer to a mesh handle which is filled by the method with a valid mesh handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Not thread-safe. </dd></dl>

</div>
</div>
<a class="anchor" id="a4e949b9d7b64f908dbe7642a35ced6c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gfx::CreatePixelShader </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>_pPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>_pShaderName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00044.html#a2594f4af34f62830d406887995a864be">BHandle</a> *&#160;</td>
          <td class="paramname"><em>_ppShader</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compiles and creates a pixel shader. </p>
<p>Opens the file with the passed path and searches for the pixel shader with the matching shader name. If the search is successful, the shader is compiled and a shader resource created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_pPath</td><td>The path to the file containing the pixel shader. </td></tr>
    <tr><td class="paramname">_pShaderName</td><td>The name of the pixel shader. </td></tr>
    <tr><td class="paramname">_ppShader</td><td>A pointer to a shader handle which is filled by the method with a valid shader handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00044.html#a4e949b9d7b64f908dbe7642a35ced6c1" title="Compiles and creates a pixel shader. ">gfx::CreatePixelShader</a> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Not thread-safe. </dd></dl>

</div>
</div>
<a class="anchor" id="a831ad24692845847b33c3e5345f36654"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gfx::CreateTexture </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>_pPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00044.html#a2594f4af34f62830d406887995a864be">BHandle</a> *&#160;</td>
          <td class="paramname"><em>_ppTexture</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new texture. </p>
<p>Creates a new texture by loading it from the given path. Supported formats are BMP, GIF, TIFF, JPG, PMG, and DDS. The created texture is represented by a handle which is returned in the last argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_pPath</td><td>The file path of the texture. </td></tr>
    <tr><td class="paramname">_ppTexture</td><td>A pointer to a texture handle which is filled by the method with a valid texture handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00044.html#a949f8894f31d7a6b933a3d4ae2442517" title="Frees the resources of a texture. ">gfx::ReleaseTexture</a> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Not thread-safe. </dd></dl>

</div>
</div>
<a class="anchor" id="adb193095d1e10af99955603a31e35ed1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gfx::CreateVertexShader </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>_pPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>_pShaderName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00044.html#a2594f4af34f62830d406887995a864be">BHandle</a> *&#160;</td>
          <td class="paramname"><em>_ppShader</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compiles and creates a vertex shader. </p>
<p>Opens the file with the passed path and searches for the vertex shader with the matching shader name. If the search is successful, the shader is compiled and a shader resource created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_pPath</td><td>The path to the file containing the vertex shader. </td></tr>
    <tr><td class="paramname">_pShaderName</td><td>The name of the vertex shader. </td></tr>
    <tr><td class="paramname">_ppShader</td><td>A pointer to a shader handle which is filled by the method with a valid shader handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00044.html#a6c4e5a2c5ab4b888ae3b0c52d104bc9a" title="Releases a vertex shader. ">gfx::ReleaseVertexShader</a> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Not thread-safe. </dd></dl>

</div>
</div>
<a class="anchor" id="add0cfb7c2c91924c2c1e826a741063e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gfx::DrawMesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00044.html#a2594f4af34f62830d406887995a864be">BHandle</a>&#160;</td>
          <td class="paramname"><em>_pMesh</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Visualizes a mesh. </p>
<p>Visualizes a mesh. Use this method to draw a mesh with generic material.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_pMesh</td><td>The handle to the mesh. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Not thread-safe. </dd></dl>

</div>
</div>
<a class="anchor" id="a7b6f8f713c5b0dbcfa1aa088e9a3d707"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float * gfx::GetCrossProduct </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>_pVector1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>_pVector2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>_pResultVector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the cross product between two 3D vectors. </p>
<p>Takes two 3D input vectors and computes the cross product between them. Each input vector is represented by an array of at least three float values. This means that you can also pass 4D input vectors, but only x, y, and z are considered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_pVector1</td><td>The first input vector with at least 3 float values. </td></tr>
    <tr><td class="paramname">_pVector2</td><td>The second input vector with at least 3 float values. </td></tr>
    <tr><td class="paramname">_pResultVector</td><td>The output vector with at least 3 float values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the output vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a802008b02b1afcdbb9b8a3d0c9f1e3b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float gfx::GetDotProduct2D </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>_pVector1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>_pVector2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the dot product between two 2D vectors. </p>
<p>Takes two 2D input vectors and computes the dot product between them. Each input vector is represented by an array of at least two float values. This means that you can also pass 3D or 4D input vectors, but only x and y are considered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_pVector1</td><td>The first input vector with at least 2 float values. </td></tr>
    <tr><td class="paramname">_pVector2</td><td>The second input vector with at least 2 float values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the dot product. </dd></dl>

</div>
</div>
<a class="anchor" id="aeff22e2da4db1cc3fe6d512be9251bfc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float gfx::GetDotProduct3D </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>_pVector1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>_pVector2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the dot product between two 3D vectors. </p>
<p>Takes two 3D input vectors and computes the dot product between them. Each input vector is represented by an array of at least three float values. This means that you can also pass 4D input vectors, but only x, y, and z are considered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_pVector1</td><td>The first input vector with at least 3 float values. </td></tr>
    <tr><td class="paramname">_pVector2</td><td>The second input vector with at least 3 float values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the dot product. </dd></dl>

</div>
</div>
<a class="anchor" id="a64f6a8f964674a2ecd70db184ca27a74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float gfx::GetDotProduct4D </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>_pVector1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>_pVector2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the dot product between two 4D vectors. </p>
<p>Takes two 4D input vectors and computes the dot product between them. Each input vector is represented by an array of at least four float values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_pVector1</td><td>The first input vector with at least 4 float values. </td></tr>
    <tr><td class="paramname">_pVector2</td><td>The second input vector with at least 4 float values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the dot product. </dd></dl>

</div>
</div>
<a class="anchor" id="a659b75013aff150b3c8ec89ef71054b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float * gfx::GetNormalizedVector </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>_pVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>_pResultVector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalizes the a 3D vector to the length 1. </p>
<p>Takes an array of 3 float values as input and normalizes it to the length</p>
<ol type="1">
<li>The result is stored in the last argument, which is an array of 3 float values allocated by the user.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_pVector</td><td>The input vector with 3 float values. </td></tr>
    <tr><td class="paramname">_pResultVector</td><td>The output vector with 3 float values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the output vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a7c8adde793a7665f30d8b9929fba0da8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float * gfx::GetProjectionMatrix </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>_FieldOfViewY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>_AspectRatio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>_Near</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>_Far</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>_pResultMatrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a 4x4 matrix which defines the clip space transformation. </p>
<p>Defines the view frustum of the observer and returns the corresponding projection matrix. The projection matrix represents the transformation from view space into clip space. The view frustum is defined by 4 values, which are the field of view angle, the aspect ratio, the near clipping plane, and the far clipping plane. The field of view angle is the angle spawned by the upper and the lower clipping plane of the view frustum. The angle is passed in degrees. The aspect ratio is defined by width / height of the window area. The dimensions width and height are measured in pixels. The near value defines the distance from the observer's eye position to the near clipping plane. The far value defines the distance from the observer's eye position to the far clipping plane.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_FieldOfViewY</td><td>The angle spawned by upper and lower clipping plane in degrees. </td></tr>
    <tr><td class="paramname">_AspectRatio</td><td>The ratio between width and height of the window area. </td></tr>
    <tr><td class="paramname">_Near</td><td>The distance from the eye position to the near clipping plane. </td></tr>
    <tr><td class="paramname">_Far</td><td>The distance from the eye position to the far clipping plane. </td></tr>
    <tr><td class="paramname">_pResultMatrix</td><td>The output matrix with 16 float values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the output matrix. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Matrices are in row-major order. </dd></dl>

</div>
</div>
<a class="anchor" id="a722fce1d717d7ac6a267497d2e953f31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float * gfx::GetRotationXMatrix </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>_Degrees</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>_pResultMatrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the 4x4 rotation matrix around the x-axis. </p>
<p>Takes an input angles in degrees and returns the corresponding 4x4 rotation matrix around the x-axis. The result is stored in the last argument, which is an array of 16 float values allocated by the user.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_Degrees</td><td>The rotation angle around the x-axis in degrees. </td></tr>
    <tr><td class="paramname">_pResultMatrix</td><td>The output matrix with 16 float values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the output matrix. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Matrices are in row-major order. </dd></dl>

</div>
</div>
<a class="anchor" id="a18874b5ad14fca0eb337801f59282317"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float * gfx::GetRotationYMatrix </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>_Degrees</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>_pResultMatrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the 4x4 rotation matrix around the y-axis. </p>
<p>Takes an input angles in degrees and returns the corresponding 4x4 rotation matrix around the y-axis. The result is stored in the last argument, which is an array of 16 float values allocated by the user.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_Degrees</td><td>The rotation angle around the y-axis in degrees. </td></tr>
    <tr><td class="paramname">_pResultMatrix</td><td>The output matrix with 16 float values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the output matrix. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Matrices are in row-major order. </dd></dl>

</div>
</div>
<a class="anchor" id="a177cad1cdbdcc5b63399d4e315d85c18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float * gfx::GetRotationZMatrix </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>_Degrees</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>_pResultMatrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the 4x4 rotation matrix around the z-axis. </p>
<p>Takes an input angles in degrees and returns the corresponding 4x4 rotation matrix around the z-axis. The result is stored in the last argument, which is an array of 16 float values allocated by the user.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_Degrees</td><td>The rotation angle around the z-axis in degrees. </td></tr>
    <tr><td class="paramname">_pResultMatrix</td><td>The output matrix with 16 float values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the output matrix. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Matrices are in row-major order. </dd></dl>

</div>
</div>
<a class="anchor" id="a5ef7f2087e613503db578fe1c6892132"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float * gfx::GetScaleMatrix </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>_Scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>_pResultMatrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the 4x4 uniform scaling matrix. </p>
<p>Takes a scaling factor and returns the corresponding 4x4 uniform scaling matrix. The result is stored in the last argument, which is an array of 16 float values allocated by the user.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_Scalar</td><td>The scaling factor. </td></tr>
    <tr><td class="paramname">_pResultMatrix</td><td>The output matrix with 16 float values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the output matrix. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Matrices are in row-major order. </dd></dl>

</div>
</div>
<a class="anchor" id="ad1f70f364a688198840ad9b4e299c02b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float * gfx::GetScaleMatrix </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>_ScalarX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>_ScalarY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>_ScalarZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>_pResultMatrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the 4x4 scaling matrix. </p>
<p>Takes 3 scaling factors and returns the corresponding 4x4 scaling matrix. The result is stored in the last argument, which is an array of 16 float values allocated by the user.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_ScalarX</td><td>The scaling factor along the x-axis. </td></tr>
    <tr><td class="paramname">_ScalarY</td><td>The scaling factor along the y-axis. </td></tr>
    <tr><td class="paramname">_ScalarZ</td><td>The scaling factor along the z-axis. </td></tr>
    <tr><td class="paramname">_pResultMatrix</td><td>The output matrix with 16 float values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the output matrix. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Matrices are in row-major order. </dd></dl>

</div>
</div>
<a class="anchor" id="a1bc546907545a0864a68f18c8f946035"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float * gfx::GetScreenMatrix </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>_pResultMatrix</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a 4x4 view projection matrix for post effects. </p>
<p>This method returns a view projection matrix which is where useful for post effects. Post effects are usually rendered by spawning a rectangle over the complete render target. Pass the returned matrix to the vertex shader to transform the vertices there. The four vertices of the rectangle should be as follows: </p>
<pre class="fragment">0.    0.0f, 1.0f, 0.0f
1.    1.0f, 1.0f, 0.0f
2.    1.0f, 0.0f, 0.0f
3.    0.0f, 0.0f, 0.0f
</pre><p>Note that the x-y-components of the vertices are also suitable as texture coordinates for full-screen textures.</p>
<p>You can use the following indices to define the two triangles of the rectangle: </p>
<pre class="fragment">0.    0, 1, 2
1.    0, 2, 3
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_pResultMatrix</td><td>The output matrix with 16 float values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the output matrix. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Matrices are in row-major order. </dd></dl>

</div>
</div>
<a class="anchor" id="a57ec8084e3d9029a47e845cac15d3f58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float * gfx::GetTranslationMatrix </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>_X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>_Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>_Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>_pResultMatrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the 4x4 identity matrix. </p>
<p>Returns the 4x4 translation matrix.</p>
<p>Returns the 4x4 identity matrix with ones in the main diagonal and zeros elsewhere. The result is stored in the argument, which is an array of 16 float values allocated by the user.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_pResultMatrix</td><td>The output matrix with 16 float values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the output matrix. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Matrices are in row-major order.</dd></dl>
<p>Takes a translation 3D vector and returns the corresponding 4x4 translation matrix. The result is stored in the last argument, which is an array of 16 float values allocated by the user.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_X</td><td>The translation along the x-axis. </td></tr>
    <tr><td class="paramname">_Y</td><td>The translation along the y-axis. </td></tr>
    <tr><td class="paramname">_Z</td><td>The translation along the z-axis. </td></tr>
    <tr><td class="paramname">_pResultMatrix</td><td>The output matrix with 16 float values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the output matrix. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Matrices are in row-major order. </dd></dl>

</div>
</div>
<a class="anchor" id="a82bff593a031d915a46fc1cde9850845"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float * gfx::GetViewMatrix </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>_pEye</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>_pAt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>_pUp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>_pResultMatrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a 4x4 matrix to transform the world into view space. </p>
<p>Takes the observer coordinate system to compute a look-at matrix, which transforms vertices from world space into view space. The observer coordinate system is defined by 3 input vectors, all passed as an array of 3 float values. The eye vector defines the position of the observer in the world. The at vector defines a point in the world, where the observer is looking to. The at vector does not have to be normalized. The view direction is calculated by normalize(at - eye). The up vector defines the orientation of the observer around the view direction. The result is stored in the last argument, which is an array of 16 float values allocated by the user.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_pEye</td><td>The world space position of the observer passed by 3 float values. </td></tr>
    <tr><td class="paramname">_pAt</td><td>A point in world space where the observer is looking at passed by 3 float values. </td></tr>
    <tr><td class="paramname">_pUp</td><td>The orientation of the observer around the view direction passed by 3 float values. </td></tr>
    <tr><td class="paramname">_pResultMatrix</td><td>The output matrix with 16 float values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the output matrix. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Matrices are in row-major order. </dd></dl>

</div>
</div>
<a class="anchor" id="acbd9fd02aa3569485d1bd1fecf83e942"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float * gfx::MulMatrix </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>_pLeftMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>_pRightMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>_pResultMatrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies two 4x4 matrices. </p>
<p>Takes a left and a right 4x4 matrix and multiplies them. Matrices are passed an array of 16 float values. The result is stored in the last argument, which is an array of 16 float values allocated by the user. </p>
<pre class="fragment">M = L * R
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_pLeftMatrix</td><td>The left input matrix with 16 float values. </td></tr>
    <tr><td class="paramname">_pRightMatrix</td><td>The right input matrix with 16 float values. </td></tr>
    <tr><td class="paramname">_pResultMatrix</td><td>The output matrix with 16 float values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the output matrix. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Matrices are in row-major order. </dd></dl>

</div>
</div>
<a class="anchor" id="a85888529ad66200d6547ae34fe6ec739"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gfx::ReleaseConstantBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00044.html#a2594f4af34f62830d406887995a864be">BHandle</a>&#160;</td>
          <td class="paramname"><em>_pConstantBuffer</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases a constant buffer. </p>
<p>Frees the resources of a constant buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_pConstantBuffer</td><td>The handle to the constant buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Not thread-safe. </dd></dl>

</div>
</div>
<a class="anchor" id="aeddab08b55ccd8a16efe82ab53e377e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gfx::ReleaseMaterial </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00044.html#a2594f4af34f62830d406887995a864be">BHandle</a>&#160;</td>
          <td class="paramname"><em>_pMaterial</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases a material. </p>
<p>Frees the material. Note that this method does not free resources which are associated with this material such as textures and shader programs. Those resources have to be released separately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_pMaterial</td><td>The handle to the material. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Not thread-safe. </dd></dl>

</div>
</div>
<a class="anchor" id="ae762f5085fa492ae0492dc5c47cae38d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gfx::ReleaseMesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00044.html#a2594f4af34f62830d406887995a864be">BHandle</a>&#160;</td>
          <td class="paramname"><em>_pMesh</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees the resources of a mesh. </p>
<p>Call this method on a mesh to free its resources again.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_pMesh</td><td>The handle to the mesh. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Not thread-safe. </dd></dl>

</div>
</div>
<a class="anchor" id="a78c27f43ce73dff5bd60a3608df827ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gfx::ReleasePixelShader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00044.html#a2594f4af34f62830d406887995a864be">BHandle</a>&#160;</td>
          <td class="paramname"><em>_pShader</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases a pixel shader. </p>
<p>Frees the resources of a pixel shader.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_pShader</td><td>The handle to the pixel shader. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Not thread-safe. </dd></dl>

</div>
</div>
<a class="anchor" id="a949f8894f31d7a6b933a3d4ae2442517"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gfx::ReleaseTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00044.html#a2594f4af34f62830d406887995a864be">BHandle</a>&#160;</td>
          <td class="paramname"><em>_pTexture</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees the resources of a texture. </p>
<p>Call this method on a texture which has been created by <a class="el" href="a00044.html#a831ad24692845847b33c3e5345f36654" title="Creates a new texture. ">gfx::CreateTexture</a>, <a class="el" href="a00044.html#a2154b88e3aa131b27d95017434e6ee30" title="Creates a new color render target. ">gfx::CreateColorTarget</a>, or <a class="el" href="a00044.html#ad6ed74de87429cb07cf8fb3840a2803d" title="Creates a new depth render target. ">gfx::CreateDepthTarget</a> to free its resources again.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_pTexture</td><td>The handle to the texture. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Not thread-safe. </dd></dl>

</div>
</div>
<a class="anchor" id="a6c4e5a2c5ab4b888ae3b0c52d104bc9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gfx::ReleaseVertexShader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00044.html#a2594f4af34f62830d406887995a864be">BHandle</a>&#160;</td>
          <td class="paramname"><em>_pShader</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases a vertex shader. </p>
<p>Frees the resources of a vertex shader.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_pShader</td><td>The handle to the vertex shader. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Not thread-safe. </dd></dl>

</div>
</div>
<a class="anchor" id="a3439794d716c31e4a42b523825b24b44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gfx::RunApplication </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_Width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_Height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>_pTitle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00001.html">IApplication</a> *&#160;</td>
          <td class="paramname"><em>_pApplication</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runs a YoshiX application. </p>
<p>This method opens a window, startups DirectX and then runs the passed YoshiX application, i.e. it calls the callback methods which are defined by the <a class="el" href="a00001.html" title="Defines an application which can be run by the render pipeline. ">gfx::IApplication</a> class. When the application is finished, DirectX is shutdown and the window is closed. To stop the application programmatically call the <a class="el" href="a00044.html#a5503e7a976d680eb47728da573361920" title="Stops the current application. ">gfx::StopApplication</a> method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_Width</td><td>The width of the render area in pixels. </td></tr>
    <tr><td class="paramname">_Height</td><td>The height of the render area in pixels. </td></tr>
    <tr><td class="paramname">_pTitle</td><td>The title of the window represented by a '\0' terminated C-string. </td></tr>
    <tr><td class="paramname">_pApplication</td><td>A pointer to the application to be run. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00001.html" title="Defines an application which can be run by the render pipeline. ">gfx::IApplication</a> </dd>
<dd>
<a class="el" href="a00044.html#a5503e7a976d680eb47728da573361920" title="Stops the current application. ">gfx::StopApplication</a> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Not thread-safe. </dd></dl>

</div>
</div>
<a class="anchor" id="aeb8029d85c8f246685de35497120b32b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gfx::SetAlphaBlending </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>_Flag</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Activates or deactivates the alpha blending mode. </p>
<p>Activates or deactivates the alpha blending mode. If activated pixels with an alpha value lesser than 1 are rendered transparent and blended into the background.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_Flag</td><td>If true alpha blending is activated otherwise it is deactivated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Not thread-safe. </dd></dl>

</div>
</div>
<a class="anchor" id="a4fa166e38ebc294b733cd4948c558299"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gfx::SetClearColor </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>_pColor</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines the background color of the window. </p>
<p>Defines the background color of the window. The window is automatically cleared with this color at the begin of each frame. Colors are defined by an array of 4 float values representing the RGBA channels.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_pColor</td><td>The background color defined by 4 float values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Not thread-safe. </dd></dl>

</div>
</div>
<a class="anchor" id="aad6870d4cf62fde0d7ae3ac2fa7d86bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gfx::SetDepthTest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00002.html#a2a77bf3decc8b6a97e25d240ac4c6a5a">SDepthTest::ETest</a>&#160;</td>
          <td class="paramname"><em>_Test</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the depth test type. </p>
<p>This method defines the depth test applied when pixel are drawn. Usually a lesser policy is driven, i.e. if a pixel has a lesser depth than the pixel currently registered in the depth buffer, then this pixel is replaced by the new pixel. Note that a lesser depth means closer to the viewer. However, sometimes other policies are necessary. For example when rendering post effects or GUI elements, the depth test has to be deactivated. In Early-Z- Pass approaches an equal policy is used. In the first (early) pass only the depth buffer (GBuffer) is filled. Then the depth buffer policy is set to equal and the scene is rendered a second time. Now only the pixel with a depth equal to the pixel registered in the depth buffer is drawn (this is usually the same pixel which won the depth test in the first pass). This approach is useful for all deferred applications which fill the GBuffer anyway or for applications which are heavily pixel bound (performance is critical because of massive pixel overdraw).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_Test</td><td>Each member of the <a class="el" href="a00002.html#a2a77bf3decc8b6a97e25d240ac4c6a5a">gfx::SDepthTest::ETest</a> enumeration. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00002.html" title="Encapsulates the enumeration of depth test policies. ">gfx::SDepthTest</a> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Not thread-safe. </dd></dl>

</div>
</div>
<a class="anchor" id="ad7db3624563f003481a8fd75b5bd8679"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gfx::SetWireFrame </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>_Flag</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Activates or deactivates the wire frame mode. </p>
<p>Activates or deactivates the wire frame mode. If activated meshes are displayed as wire frames.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_Flag</td><td>If true meshes are displayed as wire frames otherwise with solid surfaces. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Not thread-safe. </dd></dl>

</div>
</div>
<a class="anchor" id="a5503e7a976d680eb47728da573361920"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gfx::StopApplication </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stops the current application. </p>
<p>Stops the current application, which will call the release functions of the application, shutdown DirectX, and close the window.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00001.html" title="Defines an application which can be run by the render pipeline. ">gfx::IApplication</a> </dd>
<dd>
<a class="el" href="a00044.html#a3439794d716c31e4a42b523825b24b44" title="Runs a YoshiX application. ">gfx::RunApplication</a> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Not thread-safe. </dd></dl>

</div>
</div>
<a class="anchor" id="aa53c0b264e53a7101a0e268736e391a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float * gfx::TransformVector </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>_pVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>_pMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>_pResultVector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms a 3D vector by a 4x4 matrix. </p>
<p>Takes an array of 3 float values as input and transforms it by a 4x4 matrix containing 16 float values. The result is stored in the last argument, which is an array of 3 float values allocated by the user. </p>
<pre class="fragment">V' = V * M
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_pVector</td><td>The input vector with 3 float values. </td></tr>
    <tr><td class="paramname">_pMatrix</td><td>The matrix with 16 float values. </td></tr>
    <tr><td class="paramname">_pResultVector</td><td>The output vector with 3 float values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the output vector. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Matrices are in row-major order. </dd></dl>

</div>
</div>
<a class="anchor" id="a52050e7be3868189d6a0153730a429c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gfx::UploadConstantBuffer </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>_pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00044.html#a2594f4af34f62830d406887995a864be">BHandle</a>&#160;</td>
          <td class="paramname"><em>_pConstantBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uploads a byte block into the constant buffer on the GPU. </p>
<p>Uploads a byte block from the CPU into the constant buffer on the GPU. The number of uploaded bytes is equal to the number of bytes passed at the creation of the constant buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_pData</td><td>A pointer to the start of the byte block. </td></tr>
    <tr><td class="paramname">_pConstantBuffer</td><td>The handle to the constant buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Not thread-safe. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Oct 6 2013 14:52:59 for YoshiX Shader Function by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.4
</small></address>
</body>
</html>
